/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sm.jegm.iu;

import com.sun.prism.BasicStroke;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.util.List;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import javax.swing.Box;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.JTextField;
import javax.swing.SpinnerNumberModel;
import sm.jegm.graficos.MyCubicCurve;
import sm.jegm.graficos.MyEllipse;
import sm.jegm.graficos.MyLine;
import sm.jegm.graficos.MyPolyline;
import sm.jegm.graficos.MyRectangle;
import sm.jegm.graficos.MyRoundRectangle;
import sm.jegm.graficos.MyShape;
import sm.jegm.graficos.MyText;
import sm.jegm.graficos.PainToolType;
import sm.jegm.graficos.TypeFill;
import sm.jegm.graficos.TypeStroke;
import sm.jegm.myevents.LienzoEvent;
import sm.jegm.myevents.LienzoEventListener;

/**
 * Clase que define un lienzo en el cual se puede pintar.
 *
 * @author juane
 */
public class Lienzo2D extends javax.swing.JPanel {

    protected PainToolType currentPaintTool = PainToolType.POINT;

    protected Color currentColor = Color.RED;
    protected Color fillColor = Color.BLUE;

    protected int grossorValue = 1;
    protected TypeStroke currentTypeStroke = TypeStroke.CONTINUOUS;

    protected TypeFill currentTypeFill = TypeFill.UNFILLED;

    protected boolean isSmooth = false;

    double transparencyLevel = 1.0f;

    protected Point pointOld = new Point();
    protected Point pointCurrent = new Point();

    protected List<MyShape> myShapes = new ArrayList<>();
    protected MyShape selectedShape;
    protected Point2D offset;

    protected Shape clip = null;

    private ArrayList<LienzoEventListener> lienzoEventListeners;
    private boolean creatingShape = true;
    private boolean editingSelectedShape = false;
    boolean resizingSelectedShape = false;

    /**
     * Creates new form Lienzo
     */
    public Lienzo2D() {
        initComponents();

        lienzoEventListeners = new ArrayList();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setToolTipText("");
        setPreferredSize(new java.awt.Dimension(200, 200));
        setRequestFocusEnabled(false);
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    public void addLienzoEventListener(LienzoEventListener lienzoEventlistener) {
        if (lienzoEventlistener != null) {
            lienzoEventListeners.add(lienzoEventlistener);
        }
    }

    private void notifyShapeAddedEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoEventListener listener : lienzoEventListeners) {
                listener.onShapeAdded(evt);
            }
        }

    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        Graphics2D g2d = (Graphics2D) g;

        paintShapeVector(g2d);

    }

    /**
     * Pinta el array de figuras
     *
     * @param g2d
     */
    protected void paintShapeVector(Graphics2D g2d) {
        // draw a rectangle around the image section
        if (this.clip != null) {
            g2d.clip(this.clip);
        }

        myShapes.forEach((s) -> {
            s.draw(g2d);

            if (selectedShape != null) {
                if (s.equals(selectedShape)) {
                    g2d.setColor(Color.BLACK);
                    float dash[] = {2.0f};
                    g2d.setStroke(new java.awt.BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.CAP_BUTT, 2.0f, dash, 0.0f));
                    g2d.draw(new Rectangle((int) s.getBounds().getX() - 2, (int) s.getBounds().getY() - 2, (int) s.getBounds().getWidth() + 3, (int) s.getBounds().getHeight() + 3));
                }
            }
        });
    }

    /**
     * Crea la figura acorde al tipo de figura seleccionado
     *
     * @param evt
     */
    private void createShape(java.awt.event.MouseEvent evt) {
        switch (currentPaintTool) {
            case POINT:
                //System.out.println("Adding POINT to myShapes..");
                this.selectedShape = new MyLine(pointCurrent, pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);

                break;
            case LINE:
                //System.out.println("Adding LINE to myShapes..");
                this.selectedShape = new MyLine(pointCurrent, pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);

                break;
            case CUBIC_CURVE:
                if (this.selectedShape != null && this.selectedShape instanceof MyCubicCurve && ((MyCubicCurve) this.selectedShape).isCreating()) {
                    if (evt.getClickCount() == 2) {
                        //((MyCubicCurve) this.selectedShape).onDoubleClick();
                    } else {
                        ((MyCubicCurve) this.selectedShape).onClick(evt.getPoint());
                    }
                } else {
                    this.selectedShape = new MyCubicCurve(pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);
                }
                break;
            case RECTANGLE: {
                //System.out.println("Adding RECTANGLE to myShapes..");
                this.selectedShape = new MyRectangle(pointCurrent, pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);

                break;
            }
            case ROUND_RECTANGLE: {
                //System.out.println("Adding RECTANGLE to myShapes..");
                this.selectedShape = new MyRoundRectangle(pointCurrent, pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);

                break;
            }
            case ELLIPSE: {
                //System.out.println("Adding ELLIPSE to myShapes..");
                this.selectedShape = new MyEllipse(pointCurrent, pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);

                break;
            }
            case TEXT: {
                JComboBox jComboBoxFonts = new javax.swing.JComboBox();
                GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
                String[] fuentesSistema = ge.getAvailableFontFamilyNames();
                jComboBoxFonts.setModel(new DefaultComboBoxModel(fuentesSistema));

                JSpinner jSpinnerFontSizes = new JSpinner();
                jSpinnerFontSizes.setValue(1);
                SpinnerNumberModel modelSpinner = new SpinnerNumberModel(10, 1, 60, 1);
                jSpinnerFontSizes.setModel(modelSpinner);

                JTextField textToPaint = new JTextField(50);

                // By default, image of 800x600 px
                textToPaint.setText("Writting..");

                JPanel myPanel = new JPanel();
                myPanel.setLayout(new javax.swing.BoxLayout(myPanel, javax.swing.BoxLayout.PAGE_AXIS));
                myPanel.add(new JLabel("Font: "));
                myPanel.add(jComboBoxFonts);
                myPanel.add(Box.createVerticalStrut(15)); // a spacer
                myPanel.add(new JLabel("Size: "));
                myPanel.add(jSpinnerFontSizes);
                myPanel.add(Box.createVerticalStrut(15)); // a spacer
                myPanel.add(new JLabel("Text: "));
                myPanel.add(textToPaint);
                textToPaint.selectAll();
                int result = JOptionPane.showConfirmDialog(null, myPanel,
                        "Adding text", JOptionPane.OK_CANCEL_OPTION);
                if (result == JOptionPane.OK_OPTION) {
                    MyText newText = new MyText(pointCurrent, jComboBoxFonts.getSelectedItem().toString(), Font.PLAIN, Integer.valueOf(jSpinnerFontSizes.getValue().toString()), textToPaint.getText(), currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);
                    selectedShape = newText;
                }

                break;
            }

            case POLYLINE: {
                if (this.selectedShape != null && this.selectedShape instanceof MyPolyline && ((MyPolyline) this.selectedShape).isCreating()) {
                    if (evt.getClickCount() == 2) {
                        ((MyPolyline) this.selectedShape).onDoubleClick();
                    } else {
                        ((MyPolyline) this.selectedShape).onClick(evt.getPoint());
                    }
                } else {
                    this.selectedShape = new MyPolyline(pointCurrent, currentColor, currentTypeFill, fillColor, isSmooth, transparencyLevel, grossorValue, currentTypeStroke);
                }
                break;
            }
        }

        addShape(this.selectedShape);

    }

    /**
     * Añade la figura shape pasada al array de figuras, lanza el evento
     * correspondiente a dicha acción y notifica a todos los escuchadores de
     * dicho evento (ventanas internas).
     *
     * @param shape
     */
    private void addShape(MyShape shape) {
        myShapes.add(shape);

        LienzoEvent readerEvent = new LienzoEvent(this);
        notifyShapeAddedEvent(readerEvent);
    }

    /**
     * Actualiza las propiedades de la figura seleccionada según las propiedades
     * del lienzo en un determinado momento.
     */
    public void updateShapeSelectedStyle() {
        if (selectedShape != null) {
            //System.out.println("Actualizando figura seleccionada..");
            selectedShape.setFillColor(fillColor);
            selectedShape.setStrokeColor(currentColor);
            selectedShape.setShapeGrossor(grossorValue);
            selectedShape.setShapeTypeStroke(currentTypeStroke);
            selectedShape.setShapeFill(currentTypeFill);
            selectedShape.setTransparencyDegree((float) transparencyLevel);
            selectedShape.setSmoothed(isSmooth);

            repaint();
        }
    }

    /**
     * Selecciona la figura en la posición del array de figuras del index pasado
     *
     * @param index Índice de la figura a seleccionar del array de figuras
     */
    public void setSelectedShape(int index) {
        selectedShape = myShapes.get(index);
        editingSelectedShape = true;
        creatingShape = false;
    }

    /**
     * Deselecciona la figura seleccionada
     */
    public void deselectSelectedShape() {
        if (selectedShape != null) {
            selectedShape = null;
            editingSelectedShape = false;
            creatingShape = true;
        }
    }

    /**
     * Actualiza las propiedades internas del lienzo según las propiedades de la
     * figura en el índice pasado del array de figuras
     *
     * @param index
     */
    public void updateProperties(int index) {
        try {
            MyShape shape = myShapes.get(index);

            setFillColor(shape.getFillColor());
            setCurrentColor(shape.getStrokeColor());
            setGrossorValue(shape.getShapeGrossor());
            setCurrentTypeStroke(shape.getShapeTypeStroke());
            setCurrentTypeFill(shape.getShapeFill());
            setTransparencyLevel((float) shape.getTransparencyDegree());
            setIsSmooth(shape.isSmoothed());

        } catch (IndexOutOfBoundsException ex) {
            System.err.print("Error: " + ex);
        }
    }

    /**
     * Mueve la figura seleccionada hacia la posición del mouse
     */
    private void moveShape() {
        Point newLeftCorner = new Point((int) (pointCurrent.x - offset.getX()), (int) (pointCurrent.y - offset.getY())); // with offset included
        //System.out.println("new Left: " + newLeftCorner);
        this.selectedShape.setLocation(newLeftCorner);
    }

    /**
     * Mueve la figura seleccionada a la posición pasada
     *
     * @param x
     * @param y
     */
    public void setLocationSelectedShape(int x, int y) {
        if (selectedShape != null) {
            int auxx = (x == -1) ? selectedShape.getLocation().x : x;
            int auxy = (y == -1) ? selectedShape.getLocation().y : y;
            selectedShape.setLocation(new Point(auxx, auxy));
            repaint();
        }
    }

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        this.formMouseDragged(evt);
    }//GEN-LAST:event_formMouseReleased

    /**
     * Si se está en modo de creación, se crea la figura acorde al tipo de
     * figura seleccionada. Si se está en modo edición, se calcula el
     * desplazamiento desde la esquina superior izquierda hasta la posición
     * actual del mouse.
     *
     * @param evt
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        pointCurrent = evt.getPoint();
        pointOld = pointCurrent;
        if (creatingShape) {
            createShape(evt);
        } else if (editingSelectedShape) {
            if (resizingSelectedShape) {
                pointOld = selectedShape.getLocation();
            } else {
                offset = new Point(pointCurrent.x - selectedShape.getBounds().x, pointCurrent.y - selectedShape.getBounds().y);
            }
            System.out.println("Offset: " + offset);
        }
        repaint();
    }//GEN-LAST:event_formMousePressed

    /**
     * Si se está en modo edición, se actualiza el tamaño de la figura a la
     * posición del mouse en cada movimiento Si se está en modo edición, se
     * mueve la figura (con el offset previamente calculado) a la posicion del
     * mouse en cada movimiento.
     *
     * @param evt
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        pointCurrent = evt.getPoint();

        //moving shape
        if (selectedShape != null) {
            if (creatingShape) {
                selectedShape.updateShapeSize(pointOld, pointCurrent);
            } else if (editingSelectedShape) {
                if (resizingSelectedShape) {
                    selectedShape.updateShapeSize(pointOld, pointCurrent);
                } else {
                    moveShape();
                }
            }
        }
        this.repaint();
    }//GEN-LAST:event_formMouseDragged

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        if (selectedShape != null && editingSelectedShape) {
            double distx = evt.getX() - (selectedShape.getBounds().width + selectedShape.getBounds().getX());
            double disty = evt.getY() - (selectedShape.getBounds().height + selectedShape.getBounds().getY());
            if ((distx < 3 && distx > -3) && (disty < 3 && disty > -3)) {
                setCursor(new Cursor(java.awt.Cursor.SE_RESIZE_CURSOR));
                resizingSelectedShape = true;
            } else {
                setCursor(new Cursor(java.awt.Cursor.MOVE_CURSOR));
                resizingSelectedShape = false;
            }
        }
    }//GEN-LAST:event_formMouseMoved

    /* Setters and getters */
    public boolean isEditing() {
        return editingSelectedShape;
    }

    public void setIsSmooth(boolean isSmooth) {
        this.isSmooth = isSmooth;
    }

    public void setGrossorValue(int grossorValue) {
        this.grossorValue = grossorValue;
    }

    public boolean isSmooth() {
        return isSmooth;
    }

    public List<MyShape> getMyShapes() {
        return myShapes;
    }

    public int getGrossorValue() {
        return grossorValue;
    }

    public Color getCurrentColor() {
        return currentColor;
    }

    public PainToolType getCurrentPaintTool() {
        return currentPaintTool;
    }

    public void setCurrentColor(Color currentColor) {
        this.currentColor = currentColor;
    }

    public void setCurrentPaintTool(PainToolType paintTool) {
        this.currentPaintTool = paintTool;
    }

    public void setClip(Shape clip) {
        this.clip = clip;
    }

    public void setFillColor(Color fillColor) {
        this.fillColor = fillColor;
    }

    public void setCurrentTypeStroke(TypeStroke typeStroke) {
        this.currentTypeStroke = typeStroke;
    }

    public void setCurrentTypeFill(TypeFill currentTypeFill) {
        this.currentTypeFill = currentTypeFill;
    }

    public void setTransparencyLevel(double transparencyLevel) {
        this.transparencyLevel = transparencyLevel;
    }

    public MyShape getSelectedShape() {
        return selectedShape;
    }

    public Color getFillColor() {
        return fillColor;
    }

    public TypeStroke getCurrentTypeStroke() {
        return currentTypeStroke;
    }

    public TypeFill getCurrentTypeFill() {
        return currentTypeFill;
    }

    public double getTransparencyLevel() {
        return transparencyLevel;
    }

    /* END Setters and getters */

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
